# 技术决策说明

## 字体子集化技术选型

本文档记录了 LXGW Bright Web 字体项目中关于字体子集化实现的技术决策过程和原因。

## 子集化策略选择

### 问题背景

中文等 CJK 字体文件通常非常大（10-15MB），导致网页加载缓慢。传统的自托管 Web 字体方案存在以下问题：

1. **文件体积大**：完整字体文件下载耗时长
2. **首次渲染慢**：浏览器需要等待字体下载完成才能显示
3. **资源浪费**：大多数页面只使用少量字符，但需下载完整字体

### 考虑的方案

我们评估了以下几种方案：

#### 方案 1：单一压缩字体文件

优点：

- 实现简单，只需一个文件
- 缓存效率高，下载一次后所有页面共享

缺点：

- 初始加载时间长
- 即使页面只使用少量字符，也需下载完整字体

#### 方案 2：基于使用频率的字符子集

优点：

- 可以优先加载常用字符
- 文件体积明显小于完整字体

缺点：

- 难以确定哪些字符是"常用"的
- 不同网站内容差异大，通用子集不适合所有场景
- 仍然可能下载很多不需要的字符

#### 方案 3：基于 Unicode 区块的子集分割

优点：

- 浏览器可以智能下载页面中使用的字符所在的子集
- 遵循行业标准（与 Google Fonts 一致）
- 不同页面可以复用已缓存的子集

缺点：

- 首次访问时可能需要并行下载多个子集文件
- 实现复杂度较高

### 最终选择

我们最终选择了**方案 3：基于 Unicode 区块的子集分割**，原因如下：

1. **性能优势**：浏览器只下载页面中实际使用的字符子集，大幅减少下载体积
2. **符合标准**：这种方法被 Google Fonts 等主流服务采用，实践证明有效
3. **用户体验**：页面加载速度更快，字体切换更平滑
4. **灵活性**：支持动态内容，不需要预先知道页面会使用哪些字符

## 技术实现选择

### 子集划分工具选择

我们考虑了以下工具：

#### fonttools (pyftsubset)

优点：

- 功能完整，支持多种字体格式
- 可高度定制化
- 广泛使用的行业标准工具

缺点：

- 需要 Python 环境
- 命令行接口较为复杂

#### fontmin (Node.js)

优点：

- 纯 JavaScript 实现，无外部依赖
- 与 Node.js 生态集成良好

缺点：

- 功能相对有限
- 处理大型字体时性能较差
- 社区更新不如 fonttools 活跃

### 最终选择

我们选择了 **fonttools (pyftsubset)**，原因如下：

1. **可靠性**：fonttools 是字体处理的行业标准工具，经过充分测试
2. **性能**：处理大型 CJK 字体时明显更快
3. **功能**：支持更多字体特性和优化选项
4. **与 Google Fonts 一致**：Google Fonts 也使用 fonttools 进行子集化

## Unicode 范围确定策略

### 可能的来源

Unicode 范围划分有几种可能的确定方式：

1. **手动定义**：基于 Unicode 区块手动确定
2. **使用频率分析**：基于字符使用频率统计
3. **参考 Google Fonts**：使用与 Google Fonts 一致的范围划分

### 最终选择

我们选择了**参考 Google Fonts 的范围划分**，原因如下：

1. **经过验证**：Google Fonts 的划分已在全球范围内得到验证和优化
2. **兼容性好**：与主流字体服务一致，确保兼容性和可预测性
3. **维护成本低**：可以通过脚本自动从 Google Fonts 获取最新的划分策略
4. **专业性**：Google 投入了大量资源研究最佳的字体分割策略

## 字体格式支持

### 考虑的格式

我们考虑了以下 Web 字体格式：

1. **WOFF2**：最新、压缩率最高
2. **WOFF**：兼容性更广，但文件稍大
3. **TTF/OTF**：原始格式，文件最大
4. **EOT**：仅 IE 支持，已过时

### 最终选择

我们决定同时提供 **WOFF2 和 WOFF** 格式，原因如下：

1. **现代浏览器支持**：所有现代浏览器都支持 WOFF2，提供最佳性能
2. **兼容性**：WOFF 作为备用，确保较旧浏览器的兼容性
3. **无需 EOT/TTF**：这些格式体积大且不必要，现代浏览器都支持 WOFF/WOFF2

## 工作流程设计

### 关键决策

1. **脚本分离**：将 Unicode 范围获取和字体构建分为两个独立脚本
   - 原因：关注点分离，使每个脚本负责单一功能，便于维护

2. **JSON 作为中间格式**：使用 JSON 存储 Unicode 范围信息
   - 原因：结构化数据便于检查和调试，也便于手动编辑

3. **动态读取范围**：字体构建脚本动态读取 JSON 文件中的范围
   - 原因：便于更新范围而不需要修改构建脚本

4. **默认范围回退**：当 JSON 文件不存在时使用内置默认范围
   - 原因：确保即使没有范围数据也能工作，提高鲁棒性

## 未来改进方向

1. **进一步优化范围划分**：可以根据使用统计调整 Unicode 范围
2. **添加字符覆盖分析工具**：帮助开发者分析页面使用了哪些 Unicode 区块
3. **集成 CI/CD 流程**：自动更新 Unicode 范围并构建字体
4. **支持更多变体**：添加不同粗细、样式的字体变体
5. **预加载提示**：为常用区块添加预加载提示，进一步优化加载性能

## 总结

我们的技术选择基于以下原则：

1. **性能优先**：选择能提供最佳性能的方案
2. **遵循标准**：采用行业标准和最佳实践
3. **可维护性**：设计易于维护和扩展的架构
4. **用户体验**：优化最终用户体验，包括加载时间和渲染质量

通过选择基于 Unicode 区块的子集分割策略，并使用 fonttools 实现，我们创建了一个高性能、易于维护、符合行业标准的 Web 字体解决方案。
